# 读书笔记

 

### 书名：《编码：隐匿在计算机软硬件背后的语言》

### 范围：7-12章

#### 记录内容与体会：

第七章:

第七章阐述了数字系统的原理以及产生，从单纯的画线，到罗马数字，再到阿拉伯数字，同时利用阿拉伯数字引出十进制的表示方法，进一步的用10的整数幂的形式来表示，包括正数以及负数次幂。

十进制是我们生活中最常用的进制表示，作者用十进制来引出下文八进制乃至二进制的方法非常巧妙。

 

第八章：

第八章利用各种拥有不同手指数量的卡通人物作为比喻，讲述了事物不止能用十进制来表示，10也不一定表示的是十。从八进制到四进制最后到二进制，最后讲述了二进制的运算法则。最后指出“**二进制系统还在算术与电子技术之间架起了一座桥梁**”。

电势的高低，磁盘的磁性，这些东西对应着二进制的01，而正是01能够代表一切事物的特性，才有了我们现在熟知的计算机。

 

第九章：

第九章用一整章的篇幅来讲述了二进制，用0与1来进行组合，不同的组合来表达不同的意义。“**换句话说，所有可以被转换成对两种或多种可能性的选择的信息们都可以用比特来表示**”。 同时使用了生活中常见的胶片、UPC条形码作为例子，证明二进制的应用在我们身边是无处不在的。同时也用条形码引出了校验的含义。

使用条形码来讲诉二进制在生活中的应用这一段让我看入了迷。我没有想到生活中随处可见的条形码居然有如此多的思想与技术在其中，同时这也证明了二进制的优越性。

 

第十章：

第十章则开始讲诉逻辑这一在计算机内至关重要的概念。用苏格拉底的三段论法来引出布尔运算，并与代数运算进行对比。同时用猫的花色、性别、颜色等特性，来组成布尔表达式，并且用机器的方式来一步步的表达出来，最后形成了一个实现逻辑判断的机器。

逻辑运算作为计算机运算的核心，其实独立出来与作者做出的开关闭合没有什么区别，计算机的魅力就在于它的机制简洁与能实现的东西的复杂。

 

第十一章：

第十一章则对逻辑运算中所使用的诸多逻辑门进行了详细的描述，并且将它们用继电器的形式实现了出来，并给出了他们的逻辑表。

这一章中，作者手把手的教我们建造各种逻辑门，甚至还吐槽了商店中继电器的价格以及大小，正是这种细节让读者能够身临其境，能够有动手实现的欲望。



第十二章：

第十二章作为本书的一个小高潮，让我们根据上一章所拥有的各种门电路，从零开始实现了二进制加法器。通过分析加法的两个输出的特点，并将它们与逻辑门的逻辑表相比较，给出了半加器的实现方式，进一步的给出了全加器，乃至八位全加器的实现方式。

这一章将前面所讲的一切都串联起来，利用大量的逻辑门来实现了一个加法的运算，而在计算机中，正是这些运算构成了美妙的计算机世界，这也将作为计算机搭建的起点。



#### 实操环节：四位前置进位加法器的实现

在第十二章的最后，提到了前置进位相比行波进位的优越性，这是很出人意料的，因为我们所认知的进位都应该是这样一步一步进位上来，而作者指出有方法可以不用等待上一个进位，所以想要尝试一下。

图片如果显示错误，请移步https://github.com/thesickpeople/freshman2021_ReadingImg。

首先是前置进位加法器的数学推导过程：

设每一位的两个输入分别为A、B，算术结果为S，进位结果为C，字母后面跟随的数字作为这一位的标识，从0开始计数，单独的C作为初始的进位。

观察一位加法器的真值表，可以得出，对于第i位，当A、B、Ci-1中至少有两个为1时，Ci即为1。将该情况分为两部分，即，当A、B均为1时，无论Ci-1的值为多少，Ci均为1；而当A、B中只有一个为1时，需要Ci-1也为1。以此，我们可以判断出对于第i位计算，Si=Ai^Bi^Ci-1，Ci=A*B+(A+B)Ci-1。

前置进位加法器的核心就在于，这是一个可以递归到最初的C的表达式。对于一个四位前置进位加法器，令A*B=G，A+B=P，则C3=G3+P3C2，C2=G2+P2C1，C1=G1+P1C0，C0=G0+P0C。组合起来展开，即为C3=G3+P3G2+P3P2G1+P3P2P1G0+P3P2P1P0C。这样它的进位就只与最初的进位C有关系，而不再需要等待C2的计算结果。

当然，数学推导上很方便，但是在实现上需要大量的门电路，尤其是在位数大的情况下。哪怕只是模拟，画bdf图的时候也需要考虑走线冲突的问题。

![Image text](https://raw.githubusercontent.com/thesickpeople/freshman2021_ReadingImg/main/Carry-lookahead-adder_C3.png)

这是C3的实现，注意到最后使用的OR5门，同时上方还有一个负责P3P2P1P0C的AND5门。

![Image text](https://raw.githubusercontent.com/thesickpeople/freshman2021_ReadingImg/main/Carry-lookahead-adder_all.png)

这是电路的整体实现，可以看到非常凌乱，原因是门电路的增多和线路的增多，导致走线冲突非常的多，很多只能选择弯弯绕绕。

![Image text](https://raw.githubusercontent.com/thesickpeople/freshman2021_ReadingImg/main/Carry-lookahead-adderReport_1.png)

测试用例1，输入1101，1011，C=1，结果为1001，C3=1。

![Image text](https://raw.githubusercontent.com/thesickpeople/freshman2021_ReadingImg/main/Carry-lookahead-adderReport_2.png)

测试用例2，输入0101，1001，C=0，结果为1110，C3=0。